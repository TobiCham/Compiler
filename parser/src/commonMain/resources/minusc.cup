package test;

import java_cup.runtime.*;

parser code {:
:};

terminal IDENTIFIER, CONSTANT, STRING, LE_OP, GE_OP, EQ_OP, NE_OP, EXTERN, AUTO, INT, VOID, FUNCTION, IF, ELSE, WHILE, CONTINUE, BREAK, RETURN, COMMA, MINUS, ADD, MULTIPLY, DIVIDE, MOD, GREATER_THAN, LESS_THAN, SEMI_COLON, ASSIGNMENT, LEFT_CURLY, RIGHT_CURLY, LEFT_BRACKET, RIGHT_BRACKET, NOT;

non terminal Node goal, primary_expression, postfix_expression, argument_expression_list, unary_expression, unary_operator, multiplicative_expression, additive_expression, relational_expression, equality_expression, assignment_expression, expression, declaration, declaration_specifiers, init_declarator_list, init_declarator, storage_class_specifier, type_specifier, declarator, direct_declarator, parameter_list, parameter_declaration, identifier_list, abstract_declarator, direct_abstract_declarator, statement, compound_statement, declaration_list, statement_list, expression_statement, selection_statement, iteration_statement, jump_statement, translation_unit, external_declaration, function_definition;

start with goal;

goal ::= translation_unit:unit {: RESULT=unit; :};

primary_expression ::=
    IDENTIFIER:value {: RESULT = new Node(NodeType.IDENTIFIER, value); :}
    |
    CONSTANT:value {: RESULT = new Node(NodeType.CONSTANT, value); :}
    |
    STRING:value {: RESULT = new Node(NodeType.STRING, value); :}
    |
    LEFT_BRACKET expression:exp RIGHT_BRACKET {: RESULT = exp; :};

postfix_expression ::=
    primary_expression:exp {: RESULT = exp; :}
    |
    postfix_expression:exp LEFT_BRACKET RIGHT_BRACKET {: RESULT = new Node(NodeType.APPLY, exp, null); :}
    |
    postfix_expression:exp LEFT_BRACKET argument_expression_list:args RIGHT_BRACKET {: RESULT = new Node(NodeType.APPLY, exp, args); :};

argument_expression_list ::=
    assignment_expression:exp {: RESULT = exp; :}
    |
    argument_expression_list:e1 COMMA assignment_expression:e2 {: RESULT = new Node(NodeType.PARAMS_SEPARATOR, e1, e2); :};

unary_expression ::=
    postfix_expression:exp {: RESULT = exp; :}
    |
    unary_operator:op unary_expression:exp {: RESULT = new Node(NodeType.INT, op, exp); :};

unary_operator ::=
    ADD:op {: RESULT = new Node(NodeType.ADD); :}
    |
    MINUS:op {: RESULT = new Node(NodeType.SUBTRACT); :}
    |
    NOT:op {: RESULT = new Node(NodeType.NOT); :};

multiplicative_expression ::=
    unary_expression:expression {: RESULT = expression; :}
    |
    multiplicative_expression:e1 MULTIPLY unary_expression:e2 {: RESULT = new Node(NodeType.MULTIPLY, e1, e2); :}
    |
    multiplicative_expression:e1 DIVIDE unary_expression:e2 {: RESULT = new Node(NodeType.DIVIDE, e1, e2); :}
    |
    multiplicative_expression:e1 MOD unary_expression:e2 {: RESULT = new Node(NodeType.MOD, e1, e2); :};

additive_expression ::=
    multiplicative_expression:expression {: RESULT = expression; :}
    |
    additive_expression:e1 ADD multiplicative_expression:e2 {: RESULT = new Node(NodeType.ADD, e1, e2); :}
    |
    additive_expression:e1 MINUS multiplicative_expression:e2 {: RESULT = new Node(NodeType.SUBTRACT, e1, e2); :};

relational_expression ::=
    additive_expression:exp {: RESULT = exp; :}
    |
    relational_expression:e1 LESS_THAN additive_expression:e2 {: RESULT = new Node(NodeType.LESS_THAN, e1, e2); :}
    |
    relational_expression:e1 GREATER_THAN additive_expression:e2 {: RESULT = new Node(NodeType.MORE_THAN, e1, e2); :}
    |
    relational_expression:e1 LE_OP additive_expression:e2 {: RESULT = new Node(NodeType.LESS_EQ_TO, e1, e2); :}
    |
    relational_expression:e1 GE_OP additive_expression:e2 {: RESULT = new Node(NodeType.MORE_EQ_TO, e1, e2); :};

equality_expression ::=
    relational_expression:exp {: RESULT = exp; :}
    |
    equality_expression:e1 EQ_OP relational_expression:e2 {: RESULT = new Node(NodeType.EQUALS, e1, e2); :}
    |
    equality_expression:e1 NE_OP relational_expression:e2 {: RESULT = new Node(NodeType.NOT_EQUALS, e1, e2); :};

assignment_expression ::=
    equality_expression:exp {: RESULT = exp; :}
    |
    unary_expression:e1 ASSIGNMENT assignment_expression:e2 {: RESULT = new Node(NodeType.ASSIGNMENT, e1, e2); :};

expression ::=
    assignment_expression:exp {: RESULT = exp; :}
    |
    expression:e1 COMMA assignment_expression:e2 {: new Node(NodeType.PARAMS_SEPARATOR, e1, e2); :};

declaration ::=
    declaration_specifiers:dec SEMI_COLON {: RESULT = dec; :}
    |
    function_definition:def {: RESULT = def; :}
    |
    declaration_specifiers:dec init_declarator_list:list SEMI_COLON {: RESULT = new Node(NodeType.TILDE, dec, list); :};

declaration_specifiers ::=
    storage_class_specifier:spec {: RESULT = spec; :}
    |
    storage_class_specifier:spec1 declaration_specifiers:spec2 {: RESULT = new Node(NodeType.TILDE, spec1, spec2); :}
    |
    type_specifier:spec {: RESULT = spec; :}
    |
    type_specifier:spec1 declaration_specifiers:spec2 {: RESULT = new Node(NodeType.TILDE, spec1, spec2); :};

init_declarator_list ::=
    init_declarator:dec {: RESULT = dec; :}
    |
    init_declarator_list:list COMMA init_declarator:dec {: RESULT = new Node(NodeType.PARAMS_SEPARATOR, list, dec); :};

init_declarator ::=
    declarator:dec {: RESULT = dec; :}
    |
    declarator:dec ASSIGNMENT assignment_expression:exp {: RESULT = new Node(NodeType.ASSIGNMENT, dec, exp); :};

storage_class_specifier ::=
    EXTERN {: RESULT = new Node(NodeType.EXTERN); :}
    |
    AUTO {: RESULT = new Node(NodeType.AUTO); :};

type_specifier ::=
    VOID {: RESULT = new Node(NodeType.VOID); :}
    |
    INT {: RESULT = new Node(NodeType.INT); :}
    |
    FUNCTION {: RESULT = new Node(NodeType.FUNCTION); :};

declarator ::= direct_declarator:dec {: RESULT = dec; :};

direct_declarator ::=
    IDENTIFIER:value {: RESULT = new Node(NodeType.IDENTIFIER, value); :}
    |
    LEFT_BRACKET declarator:dec RIGHT_BRACKET {: RESULT = dec; :}
    |
    direct_declarator:dec LEFT_BRACKET parameter_list:params RIGHT_BRACKET {: RESULT = new Node(NodeType.FUNCTION_PARAMS, dec, params); :}
    |
    direct_declarator:dec LEFT_BRACKET identifier_list:params RIGHT_BRACKET {: RESULT = new Node(NodeType.FUNCTION_PARAMS, dec, params); :}
    |
    direct_declarator:dec LEFT_BRACKET RIGHT_BRACKET {: RESULT = new Node(NodeType.FUNCTION_PARAMS, dec, null); :};

parameter_list ::=
    parameter_declaration:dec {: RESULT = dec; :}
    |
    parameter_list:list COMMA parameter_declaration:dec {: RESULT = new Node(NodeType.PARAMS_SEPARATOR, list, dec); :};

parameter_declaration ::=
    declaration_specifiers:spec declarator:dec {: RESULT = new Node(NodeType.TILDE, spec, dec); :}
    |
    declaration_specifiers:spec abstract_declarator:dec {: RESULT = new Node(NodeType.TILDE, spec, dec); :}
    |
    declaration_specifiers:dec {: RESULT = dec; :};

identifier_list ::=
    IDENTIFIER:value {: RESULT = new Node(NodeType.IDENTIFIER, value); :}
    |
    identifier_list:list COMMA IDENTIFIER:value {: RESULT = new Node(NodeType.PARAMS_SEPARATOR, list, new Node(NodeType.IDENTIFIER, value)); :};

abstract_declarator ::=
    direct_abstract_declarator:dec {: RESULT = dec; :};

direct_abstract_declarator ::=
    LEFT_BRACKET abstract_declarator:dec RIGHT_BRACKET {: RESULT = dec; :}
    |
    LEFT_BRACKET RIGHT_BRACKET {: RESULT = null; :}
    |
    LEFT_BRACKET parameter_list:list RIGHT_BRACKET {: RESULT = list; :}
    |
    direct_abstract_declarator:dec LEFT_BRACKET RIGHT_BRACKET {: RESULT = new Node(NodeType.APPLY, dec, null); :}
    |
    direct_abstract_declarator:dec LEFT_BRACKET parameter_list:params RIGHT_BRACKET {: RESULT = new Node(NodeType.APPLY, dec, params); :};

statement ::=
    compound_statement:statement {: RESULT = statement; :}
    |
    expression_statement:statement {: RESULT = statement; :}
    |
    selection_statement:statement {: RESULT = statement; :}
    |
    iteration_statement:statement {: RESULT = statement; :}
    |
    jump_statement:statement {: RESULT = statement; :};

compound_statement ::=
    LEFT_CURLY RIGHT_CURLY {: RESULT = null; :}
    |
    LEFT_CURLY statement_list:list RIGHT_CURLY {: RESULT = list; :}
    |
    LEFT_CURLY declaration_list:list RIGHT_CURLY {: RESULT = list; :}
    |
    LEFT_CURLY declaration_list:dec statement_list:statements RIGHT_CURLY {: RESULT = new Node(NodeType.END_STATEMENT, dec, statements); :};

declaration_list ::=
    declaration:dec {: RESULT = dec; :}
    |
    declaration_list:list declaration:dec {: RESULT = new Node(NodeType.END_STATEMENT, list, dec); :};

statement_list ::=
    statement:statement {: RESULT = statement; :}
    |
    statement_list:list statement:statement {: RESULT = new Node(NodeType.END_STATEMENT, list, statement); :};

expression_statement ::=
    SEMI_COLON {: RESULT = null; :}
    |
    expression:exp SEMI_COLON {: RESULT = exp; :};

selection_statement ::=
    IF LEFT_BRACKET expression:exp RIGHT_BRACKET statement:statement {: RESULT = new Node(NodeType.IF, exp, statement); :}
    |
    IF LEFT_BRACKET expression:exp RIGHT_BRACKET statement:ifs ELSE statement:elses {: RESULT = new Node(NodeType.IF, exp, new Node(NodeType.ELSE, ifs, elses)); :};

iteration_statement ::=
    WHILE LEFT_BRACKET expression:exp RIGHT_BRACKET statement:body {: RESULT = new Node(NodeType.WHILE, exp, body); :};

jump_statement ::=
    CONTINUE SEMI_COLON {: RESULT = new Node(NodeType.CONTINUE); :}
    |
    BREAK SEMI_COLON {: RESULT = new Node(NodeType.BREAK); :}
    |
    RETURN SEMI_COLON {: RESULT = new Node(NodeType.RETURN); :}
    |
    RETURN expression:exp SEMI_COLON {: RESULT = new Node(NodeType.RETURN, exp, null); :};

translation_unit ::=
    external_declaration:dec {: RESULT = dec; :}
    |
    translation_unit:unit external_declaration:dec {: RESULT = new Node(NodeType.TILDE, unit, dec); :};

external_declaration ::=
    declaration:dec {: RESULT = dec; :};

function_definition ::=
    declaration_specifiers:spec declarator:dec declaration_list:list compound_statement:statement {:
        RESULT = new Node(NodeType.FUNCTION_DEF, new Node(NodeType.FUNCTION_DATA, spec, new Node(NodeType.EXTERN, dec, list)), statement);
    :}
    |
    declaration_specifiers:spec declarator:dec compound_statement:statement {:
        RESULT = new Node(NodeType.FUNCTION_DEF, new Node(NodeType.FUNCTION_DATA, spec, dec), statement);
    :}
    |
    declarator:dec declaration_list:list compound_statement:statement {:
        RESULT = new Node(NodeType.FUNCTION_DEF, new Node(NodeType.FUNCTION_DATA, dec, list), statement);
    :}
    |
    declarator:dec compound_statement:statement {: RESULT = new Node(NodeType.FUNCTION_DATA, dec, statement); :};

